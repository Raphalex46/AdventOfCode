{-# OPTIONS_GHC -Wno-name-shadowing #-}

module Main where

import Data.Char
import Data.List

-- Define card data structure
data Card = Card Int [Int] [Int] deriving (Show)

-- Parse puzzle input
parseInput :: [String] -> [Card]
parseInput i =
  map parseLine i
  where
    -- Do splits and spans and stuff to parse the string. Not too difficult
    parseLine l =
      let (idStr, nums) = span (/= ':') l
          id = read $ dropWhile (not . isDigit) idStr
          (winNums, yourNums) =
            let (a, b) = span (/= '|') nums
                fil = filter $ (\x -> isDigit x || isSpace x)
             in (map read $ words . fil $ a, map read $ words . fil $ b)
       in Card id winNums yourNums

-- Returns the number of matching numbers in a card
numMatching :: Card -> Int
numMatching (Card _ w y) = length (w `intersect` y)

-- Compute the score of a card (for problem 1)
computeScore :: Card -> Int
computeScore c =
  case numMatching c of
    0 -> 0
    a -> 2 ^ (a - 1)

-- Count the numbers of cards and card copies
countCards :: [Card] -> Int
countCards c =
  let len = length c
   in -- Don't forget the original cards !
      len + countCards' c (replicate len 1)
  where
    -- Auxiliary function which takes 2 lists: the cards and the number of copies
    -- of the corresponding card. We go through the list linearly:
    -- add the number of cards generated by each card (i.e. the number of copies
    -- of this card * the matching score of the card) and then call the function
    -- recursively while updating the second parameter (list of the number of card
    -- copies) accordingly
    countCards' (c : cs) (n : ns) =
      (nm * n) + countCards' cs ([x + n | x <- (take nm ns)] ++ (drop nm ns))
      where
        nm = numMatching c
    -- Don't forget the edge case...
    countCards' [] _ = 0
    -- This one should not happen
    countCards' _ [] = 0

solution1 :: [Card] -> Int
solution1 = sum . map computeScore

solution2 :: [Card] -> Int
solution2 = countCards

main :: IO ()
main = do
  inputStr <- readFile "input.txt"
  let input = lines inputStr
      parsedInput = parseInput input
      sol1 = solution1 parsedInput
      sol2 = solution2 parsedInput
  putStrLn $ "Solution to problem 1: " ++ show sol1
  putStrLn $ "Solution to problem 2: " ++ show sol2
